<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Kafka 系列 - 生产者 | Java 开发知识体系</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="xxxx">
    
    <link rel="preload" href="/assets/css/0.styles.f111fb23.css" as="style"><link rel="preload" href="/assets/js/app.0231cced.js" as="script"><link rel="preload" href="/assets/js/2.972344c2.js" as="script"><link rel="preload" href="/assets/js/23.1898e8f1.js" as="script"><link rel="prefetch" href="/assets/js/10.3837ac29.js"><link rel="prefetch" href="/assets/js/11.18aa115b.js"><link rel="prefetch" href="/assets/js/12.cce639b3.js"><link rel="prefetch" href="/assets/js/13.771d4a93.js"><link rel="prefetch" href="/assets/js/14.b7a7b293.js"><link rel="prefetch" href="/assets/js/15.dc69d892.js"><link rel="prefetch" href="/assets/js/16.a965be8e.js"><link rel="prefetch" href="/assets/js/17.5d2d380f.js"><link rel="prefetch" href="/assets/js/18.05df3d31.js"><link rel="prefetch" href="/assets/js/19.58306047.js"><link rel="prefetch" href="/assets/js/20.3f850222.js"><link rel="prefetch" href="/assets/js/21.b179c6c0.js"><link rel="prefetch" href="/assets/js/22.0e3ebac6.js"><link rel="prefetch" href="/assets/js/3.dc578df3.js"><link rel="prefetch" href="/assets/js/4.9126ee63.js"><link rel="prefetch" href="/assets/js/5.dbceb499.js"><link rel="prefetch" href="/assets/js/6.084197a9.js"><link rel="prefetch" href="/assets/js/7.305b84ee.js"><link rel="prefetch" href="/assets/js/8.a5d627b3.js"><link rel="prefetch" href="/assets/js/9.259ccf49.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f111fb23.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Java 开发知识体系</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><span class="title">中间件</span> <span class="arrow down"></span></button> <button type="button" aria-label="中间件" class="mobile-dropdown-title"><span class="title">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          消息中间件
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/middleware/kafka/Kafka系列一消息队列.html" class="nav-link">
  Kafka 系列
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具｜部署" class="dropdown-title"><span class="title">工具｜部署</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具｜部署" class="mobile-dropdown-title"><span class="title">工具｜部署</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          IntelliJ
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/devops/intellij/recommoned/禁用非必需插件，让 IDE 飞起.html" class="nav-link">
  实用插件推荐
</a></li><li class="dropdown-subitem"><a href="/md/devops/intellij/plugin/Simple Deployment.html" class="nav-link">
  插件开发
</a></li></ul></li><li class="dropdown-item"><h4>
          CI &amp; CD
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/devops/tool/Jenkins安装及自动部署.html" class="nav-link">
  Jenkins
</a></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><span class="title">中间件</span> <span class="arrow down"></span></button> <button type="button" aria-label="中间件" class="mobile-dropdown-title"><span class="title">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          消息中间件
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/middleware/kafka/Kafka系列一消息队列.html" class="nav-link">
  Kafka 系列
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具｜部署" class="dropdown-title"><span class="title">工具｜部署</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具｜部署" class="mobile-dropdown-title"><span class="title">工具｜部署</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          IntelliJ
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/devops/intellij/recommoned/禁用非必需插件，让 IDE 飞起.html" class="nav-link">
  实用插件推荐
</a></li><li class="dropdown-subitem"><a href="/md/devops/intellij/plugin/Simple Deployment.html" class="nav-link">
  插件开发
</a></li></ul></li><li class="dropdown-item"><h4>
          CI &amp; CD
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/devops/tool/Jenkins安装及自动部署.html" class="nav-link">
  Jenkins
</a></li></ul></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Kafka 系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/md/middleware/kafka/Kafka系列一消息队列.html" class="sidebar-link">Kafka 系列 - 消息队列</a></li><li><a href="/md/middleware/kafka/Kafka系列二消息队列的选择.html" class="sidebar-link">Kafka 系列 - 消息队列的选择</a></li><li><a href="/md/middleware/kafka/Kafka系列三基础概念.html" class="sidebar-link">Kafka 系列 - 基础概念</a></li><li><a href="/md/middleware/kafka/Kafka系列四生产者.html" class="active sidebar-link">Kafka 系列 - 生产者</a></li><li><a href="/md/middleware/kafka/Kafka系列五消费者.html" class="sidebar-link">Kafka 系列 - 消费者</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>一条消息从生产到发送成功，需要经过多个步骤，多个组件。首先要经过拦截器、序列化器、分区器对消息进行预处理，然后将消息按批次放入缓冲区，之后由 Sender 线程将消息发送到对应的节点以及分区。以下是大概流程</p> <p><img src="https://www.lin2j.tech/blog-image/kafka/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="生产者流程图"></p> <h1 id="生产者的配置"><a href="#生产者的配置" class="header-anchor">#</a> 生产者的配置</h1> <p>生产者对应的类是 KafkaProducer&lt;K,V&gt;，它是个泛型，其中 K 和 V 分别对应 <code>key.serializer</code> 和 <code>value.serializer</code> 参数的类型。</p> <p>实例化一个生产者需要有以下三个<strong>必填参数</strong>。</p> <ol><li><p><code>bootstrap.servers</code>：指定生产者客户端要链接的 Kafka 集群地址，多个地址通过英文逗号分隔，比如 host1:ip1,host2:ip2 。可以不用配置全部的地址清单，因为生产者会从给定的 broker 里获取其他 broker 的信息。不过还是建议配置多几个，保证其中一个 broker 宕机后，还能连上 Kafka 集群。</p></li> <li><p><code>key.serializer</code> 和 <code>value.serializer</code>：因为 broker 端接收到的消息必须以字节数组的形式存在，因此在将消息发送到 broker 之前，需要对消息的 key 和 value 进行序列化操作转换成字节数组。参数的值<strong>一定要是序列化器的类的全限定名称</strong>。以 StringSerializer 为例，一般在代码中用这种方式去获取全限定名称，以保证不会出错。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ProducerConfig</span><span class="token punctuation">.</span><span class="token constant">KEY_SERIALIZER_CLASS_CONFIG</span><span class="token punctuation">,</span><span class="token class-name">StringSeriablizer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <p>当然还有其他的参数可以根据实际需要去合理配置，比如 <code>batch.size</code> 、<code>acks</code>、<code>linger.ms</code>、<code>max.request.size</code> 等等。</p> <h1 id="发送"><a href="#发送" class="header-anchor">#</a> 发送</h1> <h2 id="消息的构建"><a href="#消息的构建" class="header-anchor">#</a> 消息的构建</h2> <p>Kafka 中的消息对应的类是 ProducerRecord&lt;K,V&gt; 它是个泛型，其中 K 和 V 分别对应 <code>key.serializer</code> 和 <code>value.serializer</code> 参数的类型。一条消息要发送的时候，需要先构建消息，即创建 ProducerRecord 对象，此时 topic 和 value 属性是必填项。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ProducerRecord</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当需要直接指定分区或者 key 的时候，还可以使用以下的构造方法。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ProducerRecord</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">Integer</span> partition<span class="token punctuation">,</span> <span class="token class-name">Long</span> timestamp<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Header</span><span class="token punctuation">&gt;</span></span> headers<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="消息的发送方式"><a href="#消息的发送方式" class="header-anchor">#</a> 消息的发送方式</h2> <p>发送消息时，可以调用 KafkaProducer 的 send 方法。这个方法有两个重载方法。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RecordMetadata</span><span class="token punctuation">&gt;</span></span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">ProducerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> record<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RecordMetadata</span><span class="token punctuation">&gt;</span></span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">ProducerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> record<span class="token punctuation">,</span> <span class="token class-name">Callback</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以看到调用之后，会返回一个 Future 对象，甚至还可以传入一个 Callback 用来作为消息发送之后的回调操作。</p> <p>根据对以上两个方法的不同调用，可以实现三种发送方式：<strong>发后即忘（fire-and-forget）、同步（sync）及异步（async）</strong>。</p> <ul><li><p><strong>fire-and-forget</strong>：指发送过后，不管成功与否，都不会做任何后续操作。这意味着如果消息发送失败了，那么也就丢失了，<strong>可靠性变差，但是性能最高</strong>。</p></li> <li><p><strong>sync</strong>：指消息发送之后，线程阻塞等待发送结果。需要使用到返回的 Future 对象。比如：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">try</span><span class="token punctuation">{</span>
    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RecordMetadata</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 调用 get 方法会阻塞当前线程直到方法有返回</span>
    <span class="token class-name">RecordMetadata</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 对 result 进行操作</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> <span class="token operator">|</span> <span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 异常处理</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>同步发送的<strong>可靠性高</strong>，只有两个结果：要么成功，要么异常。发生异常的时候，还可以根据情况去做处理。</p></li> <li><p><strong>async</strong>：异步发送需要用到 Callback 对象，在 Kafka 有响应的时候进行回调，要么成功，要么抛出异常。比如：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token annotation punctuation">@Overrid</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCompletion</span><span class="token punctuation">(</span><span class="token class-name">RecordMetadata</span> metadata<span class="token punctuation">,</span> <span class="token class-name">Exception</span> exception<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>exception <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 发送成功，可以打印 metadata 的信息等</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           <span class="token comment">// 发送失败，处理异常</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>对于 onCompletion 的两个参数 metadata 和 exception ，他们是互斥的：消息发送成功，metadata 不为 null，exception 为 null；消息发送异常，metadata 为 null，exception 不为 null。</p> <ul><li><p>如果<strong>使用 Futrue 对象来做回调</strong>，是否可以？</p> <p>理论上是可以的，但是当发送的消息很多时，就需要处理很多的 Future 对象。而且什么时候调用 get 方法，也是一个问题，会使问题处理起来变得麻烦，代码变得混乱。</p></li></ul></li></ul> <h2 id="异常的类型"><a href="#异常的类型" class="header-anchor">#</a> 异常的类型</h2> <p>在发送消息的过程，可能发生异常，这里的异常主要分为两种：可重试异常和不可重试异常。</p> <p>常见的可重试异常有：NetworkException、LeaderNotAvailableException、NotEnoughRelicasException、UnknownTopicOrPartitionException 等。</p> <p>发生可重试异常时，如果配置了 <code>retries</code> 参数（默认为0），那么就会在规定的次数里进行重试。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ProducerConf</span><span class="token punctuation">.</span><span class="token constant">RETRIES_CONFIG</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>不可重试异常比如 RecordTooLargeException ，说明发送的消息太大，这种是通过重试解决不了的，Kafka 会直接抛出异常。</p> <h1 id="序列化"><a href="#序列化" class="header-anchor">#</a> 序列化</h1> <p>前面提到，broker 接收到的消息必须以字节数组的形式存在，因此发送前需要对消息进行序列化。</p> <p>Kafka 中的序列化器都实现了 org.apache.kafka.common.serialization.Serializer 接口，它有 3 个方法。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 为序列化器做一些配置工作</span>
<span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> configs<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isKey<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将消息转化为字节数组</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">T</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 关闭序列化器，这个方法时继承自 java.io.Closable 接口</span>
<span class="token comment">// 一般情况下，该方法是个空方法，如果要实现，需要保证该方法的幂等性</span>
<span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>与序列化器对应的是反序列化器，反序列化器用于在消费者将从 Kafka 获得的字节数组转换为响应的对象。</p> <p>对于 String 类型的 key 和 value ，可以用 Kafka 自带的 StringSerializer 序列化器。除此之外，还有针对 ByteArray、ByteBuffer、Bytes、Double、Integer、Long 这几种类型的序列化器。</p> <p>可以看一下 StringSerializer 类的实现，代码比较简单，可以对 Serializer 接口有更进一步的认识。</p> <p>如果自带的序列化器无法满足应用需求，则可以使用入 Avro、JSON、ProtoBuf  等等通用的序列化工具来实现。</p> <h1 id="分区器"><a href="#分区器" class="header-anchor">#</a> 分区器</h1> <p>消息经过序列化之后，就要确定要发往的分区了。如果消息的 ProducerRecord 有指定 partition 字段，那么就不需要分区器的作用，因为 partition 代表所要发往的分区号。</p> <p>如果没有指定 partition 字段，就需要用分区器计算 partition 字段。Kafka 中提供了一个默认的分区器 DefaultPartitioner，它实现了 Partitioner 接口，它定义了以下两个方法</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 根据消息计算分区</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> keyBytes<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> valueBytes<span class="token punctuation">,</span> <span class="token class-name">Cluster</span> cluster<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 关闭分区器</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>除此之外，它还继承了 Configurable 接口，因此还有一个方法用来配置分区器的信息和初始化数据。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> configs<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="defaultpartitioner"><a href="#defaultpartitioner" class="header-anchor">#</a> DefaultPartitioner</h2> <p>DefaultPartitioner 在计算 partition 字段上时，会判断传入的 key 是否为 null。 DefaultPartitioner 的实现很简短，可以直接看代码。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultPartitioner</span> <span class="token keyword">implements</span> <span class="token class-name">Partitioner</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">&gt;</span></span> topicCounterMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> configs<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token comment">/**
     * @param topic 		topic的名称
     * @param key 			消息的key，可以为null
     * @param keyBytes 		消息的key对应的字节数组，可以为null
     * @param value 		消息的value，可以为null
     * @param valueBytes 	消息的value对应的字节数组，可以为null
     * @param cluster 		集群的信息
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> keyBytes<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> valueBytes<span class="token punctuation">,</span> <span class="token class-name">Cluster</span> cluster<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 从集群中获取分区数目，用于对哈希值进行取模</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PartitionInfo</span><span class="token punctuation">&gt;</span></span> partitions <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">partitionsForTopic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> numPartitions <span class="token operator">=</span> partitions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyBytes <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 当 key 为null时，会在所有可用的分区中，选择一个分区</span>
            <span class="token keyword">int</span> nextValue <span class="token operator">=</span> <span class="token function">nextValue</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 获取所有可用分区</span>
            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PartitionInfo</span><span class="token punctuation">&gt;</span></span> availablePartitions <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">availablePartitionsForTopic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>availablePartitions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> part <span class="token operator">=</span> <span class="token class-name">Utils</span><span class="token punctuation">.</span><span class="token function">toPositive</span><span class="token punctuation">(</span>nextValue<span class="token punctuation">)</span> <span class="token operator">%</span> availablePartitions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 在可用分区中选择</span>
                <span class="token keyword">return</span> availablePartitions<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果可用分区数为 0，那就在所有的分区中进行选择</span>
                <span class="token keyword">return</span> <span class="token class-name">Utils</span><span class="token punctuation">.</span><span class="token function">toPositive</span><span class="token punctuation">(</span>nextValue<span class="token punctuation">)</span> <span class="token operator">%</span> numPartitions<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果 key 不为 null，使用 MurmurHash2 算法进行哈希。</span>
            <span class="token keyword">return</span> <span class="token class-name">Utils</span><span class="token punctuation">.</span><span class="token function">toPositive</span><span class="token punctuation">(</span><span class="token class-name">Utils</span><span class="token punctuation">.</span><span class="token function">murmur2</span><span class="token punctuation">(</span>keyBytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> numPartitions<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 可以理解为获取一个对应 topic 的随机数
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">nextValue</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">AtomicInteger</span> counter <span class="token operator">=</span> topicCounterMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> counter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">AtomicInteger</span> currentCounter <span class="token operator">=</span> topicCounterMap<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>currentCounter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                counter <span class="token operator">=</span> currentCounter<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> counter<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><h2 id="自定义分区器"><a href="#自定义分区器" class="header-anchor">#</a> 自定义分区器</h2> <p>如果要按照自身的需要去设计分区逻辑，可以自定义一个分区器，只需要实现  Partitioner 接口，然后在启动的时候，指定对应的分区器即可。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ProducerConfig</span><span class="token punctuation">.</span><span class="token constant">PARTITIONER_CLASS_CONFIG</span><span class="token punctuation">,</span> <span class="token string">&quot;自定义分区器的全限定名&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h1 id="生产者拦截器"><a href="#生产者拦截器" class="header-anchor">#</a> 生产者拦截器</h1> <p>生产者拦截器可以实现在消息发送前与应答后做一些定制化的需求，比如过滤某些消息。</p> <h3 id="producerinterceptor-接口"><a href="#producerinterceptor-接口" class="header-anchor">#</a> ProducerInterceptor 接口</h3> <p>生成者拦截器需要实现 ProducerInterceptor 接口，它继承了 Configurable 接口，并且定义了一下三个方法</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ProducerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">onSend</span><span class="token punctuation">(</span><span class="token class-name">ProducerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> record<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onAcknowledgement</span><span class="token punctuation">(</span><span class="token class-name">RecordMetadata</span> metadata<span class="token punctuation">,</span> <span class="token class-name">Exception</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>onSend</strong> 方法在序列化和分区分配之前调用。如果在这一步修改了 key 或者 topic 的信息，会影响到下一步分区操作，因为分区时用的 key 和 topic 是来自拦截器的，而不是最开始的 key 和 topic。因此<strong>一般不要修改 ProducerRecord 的 key 、value、topic 等信息</strong>，否则可能会产生与预期不同的结果或者异常，同样会影响 broker 端的日志压缩。</p> <p><strong>onAcknowledgement</strong> 方法在消息已被 broker 端确认之后，或者发送到 broker 之前失败时调用，并且是先于 send 方法中指定的 Callback 调用的。这个方法一般运行在 $I/O$ 线程中，因此越简单越好，否则会影响消息的发送速度。</p> <p><strong>close</strong> 方法主要是关闭拦截器，做资源清理工作。</p> <h3 id="拦截器的调用顺序"><a href="#拦截器的调用顺序" class="header-anchor">#</a> 拦截器的调用顺序</h3> <p>拦截器的配置方式如下</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ProducerConfig</span><span class="token punctuation">.</span><span class="token constant">INTERCEPTOR_CLASSES_CONFIG</span><span class="token punctuation">,</span> <span class="token string">&quot;拦截器1的全限定名,拦截器2的全限定名&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果有多个拦截器，可以通过英文逗号将这些拦截器的全限定名连接起来，并且拦截器之间的执行顺序是按照配置的时候的顺序调用的，比如这里拦截器1会早于拦截器2被执行。</p> <p><strong>尽量不要让后面的拦截器去依赖前面拦截器的执行结果</strong>。</p> <h1 id="消息累加器"><a href="#消息累加器" class="header-anchor">#</a> 消息累加器</h1> <p>消息累加器（RecordAccumulator）也叫消息收集器。</p> <p>消息客户端是由两个线程协调运行的</p> <ul><li>主线程完成消息从生产到拦截器、序列化器、分区器的过程；</li> <li>Sender 线程负责从消息累加器中获取消息并将其发送到 Kafka 中。</li></ul> <p>消息从主线程中生产后，会先缓存到消息累加器中，等待 Sender 线程批量发送。</p> <p>消息累加器内部为每个分区都维护了一个双端队列 Deque 用来存储 ProducerBatch，ProducerBatch 中包含一个或者多个 ProducerRecord。使用 ProducerBatch 可以批量发送消息，减少网络请求次数，提高吞吐量。</p> <p>消息累加器的大小通过参数 <code>buffer-memory</code> 决定，默认是 32M。</p> <h3 id="copyonwritemap"><a href="#copyonwritemap" class="header-anchor">#</a> CopyOnWriteMap</h3> <p>上文提到消息累加器内部为每个分区维护了一个双端队列，这个对应关系是通过 CopyOnWriteMap 这个数据结构实现的。</p> <p>CopyOnWriteMap 是 Kafka 实现的一个线程安全的 Map 类型的数据结构。</p> <p>在 RecordAccumulator 中，声明一个该类型的成员变量 batches，这个对象的 key 是消息主题的分区，value 是一个双端队列。</p> <p>之所以需要自定义一个数据结构，是因为</p> <ul><li><p>为了维持分区到队列的关系，这个结构最好是 key-value 类型的，所以锁定 Map 类型的结构。</p></li> <li><p>Kafka 的生产者会在大量生产消息时，会有大量的数据涌入消息累加器，所以这个数据结构需要是线程安全的。</p></li> <li><p>大量涌入数据的同时，对应的是对 batches 对象的大量读，而分区的数量一般不会有什么变化，因此面对的是一个读多写少的情况。Kafka 通过模仿 CopyOnWriteList 实现了 CopyOnWriteMap 数据结构，采用读写分离来解决读多写少的问题又保证了线程安全。</p></li></ul> <h3 id="producerbatch"><a href="#producerbatch" class="header-anchor">#</a> ProducerBatch</h3> <p>上文提到双端队列中存储的对象类型是 ProducerBatch ，而这个对象的大小是由 <code>batch.size</code> 参数决定的，默认是 16k ，整个缓存的大小是 32M。</p> <p>在频繁的发送消息的过程中，势必会不断创建 ProducerBatch 对象，如果每次都通过 GC 来回收内存，这样会发生频繁的 GC，影响性能。</p> <p>因此 Kafka 在缓存中设计了一个内存池，16k 的内存如果用完了，就返回给内存池，需要的时候再向内存池申请。这是一种提高性能的不错实践。</p> <h1 id="sender线程"><a href="#sender线程" class="header-anchor">#</a> Sender线程</h1> <p>把消息放进缓冲区之后，与此同时会有一个独立线程Sender去把一个个Batch发送给对应的主机。</p> <h1 id="整体架构图"><a href="#整体架构图" class="header-anchor">#</a> 整体架构图</h1> <p><img src="https://www.lin2j.tech/blog-image/kafka/%E7%94%9F%E4%BA%A7%E8%80%85%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="生产者整体架构图"></p> <h1 id="重要的参数"><a href="#重要的参数" class="header-anchor">#</a> 重要的参数</h1> <h3 id="acks-消息验证"><a href="#acks-消息验证" class="header-anchor">#</a> acks 消息验证</h3> <p>消息发送到服务器之后，有三种方式认为是否发送成功</p> <ul><li>1：只要 leader 副本写入成功，就会收到来自服务器的成功响应；</li> <li>0：发送消息后不需要等待服务器响应就算发送成功；</li> <li>-1：需要 ISR 中所有的副本写入成功才能收到来自服务器的成功响应；</li> <li>all：同 -1 。</li></ul> <h3 id="retries-重试次数"><a href="#retries-重试次数" class="header-anchor">#</a> retries 重试次数</h3> <p>有时候发生网络错误可能发送不成功，但是下一秒就好了，因此可以设置重试机制。</p> <h3 id="batch-size-批次大小"><a href="#batch-size-批次大小" class="header-anchor">#</a> batch.size 批次大小</h3> <p>ProducerBatch 的大小，默认是 16k，设置大一点可以提高吞吐量。</p> <h3 id="linger-size-发送时间限制"><a href="#linger-size-发送时间限制" class="header-anchor">#</a> linger.size 发送时间限制</h3> <p>消息发送的条件有两个，一个是数据量达到 batch.size 指定的大小，一个是达到了 <code>linger.size</code> 指定的时间。达到时间限制后，就算数据量很小也会被发送。</p> <h3 id="buffer-memory-缓冲区大小"><a href="#buffer-memory-缓冲区大小" class="header-anchor">#</a> buffer.memory 缓冲区大小</h3> <p>当发送速率比不上生产速率时，需要一个缓冲区来减小发送的压力。默认是 32M。</p> <h3 id="max-request-size-最大消息大小"><a href="#max-request-size-最大消息大小" class="header-anchor">#</a> max.request.size 最大消息大小</h3> <p>用来控制发送的消息的最大大小，默认是 1M。当超过限制大小时就会抛出 RecordTooLargeException 异常。</p> <h3 id="request-timeout-ms-请求超时"><a href="#request-timeout-ms-请求超时" class="header-anchor">#</a> request.timeout.ms 请求超时</h3> <p>消息发送之后的超时等待时间，默认时 30 秒。超过等待时间会抛出 TimeoutException 。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/md/middleware/kafka/Kafka系列三基础概念.html" class="prev">
        Kafka 系列 - 基础概念
      </a></span> <span class="next"><a href="/md/middleware/kafka/Kafka系列五消费者.html">
        Kafka 系列 - 消费者
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.0231cced.js" defer></script><script src="/assets/js/2.972344c2.js" defer></script><script src="/assets/js/23.1898e8f1.js" defer></script>
  </body>
</html>
